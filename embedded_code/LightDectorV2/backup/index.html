<!DOCTYPE html>
<html>
<head>
    <title>å…‰çº¿å¼ºåº¦æ¢æµ‹å™¨ V2</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif; 
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        h1 { 
            color: #333; 
            margin: 0 0 20px 0;
            font-size: 1.8em;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2, h3 { 
            color: #444; 
            margin-top: 0;
        }
        
        .status-panel { 
            background: linear-gradient(135deg, #e8f4fd 0%, #d1e7f7 100%);
            padding: 15px; 
            margin: 15px 0;
            border-radius: 10px;
            border-left: 5px solid #2196F3;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .status-panel div {
            margin: 8px 0;
            font-size: 0.95em;
        }
        
        .status-panel strong {
            color: #1976D2;
            margin-right: 5px;
        }
        
        .control-panel { 
            margin: 20px 0; 
            padding: 20px; 
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: linear-gradient(135deg, #f9f9f9 0%, #f5f5f5 100%);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-panel h3 {
            margin-top: 0;
            color: #555;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        button, select { 
            margin: 0;
            padding: 10px 18px; 
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button:hover { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        select {
            background: white;
            cursor: pointer;
        }
        
        select:hover {
            border-color: #667eea;
        }
        
        #strobePanel {
            display: none;
            background: linear-gradient(135deg, #fffacd 0%, #fff8dc 100%);
            padding: 15px;
            margin: 15px 0;
            border-radius: 10px;
            border-left: 5px solid #ffd700;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        #strobePanel h3 {
            margin: 0;
            color: #8b6914;
        }
        
        .data-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .chart-container {
            background: #fafafa;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .chart-container h3 {
            margin-top: 0;
            color: #555;
        }
        
        .info-container {
            background: #fafafa;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .info-container h3 {
            margin-top: 0;
            color: #555;
        }
        
        #systemInfo p {
            margin: 12px 0;
            padding: 8px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }
        
        /* æ¨ªå±è®¾å¤‡ï¼ˆPCå’Œæ¨ªå±ç§»åŠ¨è®¾å¤‡ï¼‰ */
        @media (orientation: landscape) and (min-width: 768px) {
            body {
                padding: 20px;
            }
            
            .container {
                padding: 30px;
            }
            
            .data-panel {
                grid-template-columns: 2fr 1fr;
            }
            
            .button-group {
                gap: 10px;
            }
        }
        
        /* ç«–å±è®¾å¤‡ï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰ */
        @media (orientation: portrait) {
            body {
                padding: 8px;
            }
            
            .container {
                padding: 15px;
                border-radius: 12px;
            }
            
            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }
            
            .status-panel {
                padding: 12px;
                font-size: 0.9em;
            }
            
            .control-panel {
                padding: 15px;
            }
            
            .button-group {
                gap: 6px;
            }
            
            button, select {
                padding: 8px 12px;
                font-size: 0.85em;
                flex: 1 1 auto;
                min-width: calc(50% - 3px);
            }
            
            .data-panel {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            /* ç«–å±æ—¶ï¼Œæ›²çº¿å›¾æ”¾åœ¨ä¸‹éƒ¨å¹¶å æ»¡å®½åº¦ */
            .data-panel {
                display: flex;
                flex-direction: column;
            }
            
            .info-container {
                order: 1;
            }
            
            .chart-container {
                order: 2;
                width: 100%;
            }
            
            .chart-container canvas {
                width: 100% !important;
                height: auto !important;
            }
        }
        
        /* å°å±å¹•è®¾å¤‡ä¼˜åŒ– */
        @media (max-width: 480px) {
            h1 {
                font-size: 1.3em;
            }
            
            .status-panel div {
                font-size: 0.85em;
            }
            
            button, select {
                font-size: 0.8em;
                padding: 7px 10px;
                min-width: calc(50% - 3px);
            }
            
            .chart-container, .info-container {
                padding: 12px;
            }
        }
        
        /* å¤§å±å¹•è®¾å¤‡ä¼˜åŒ– */
        @media (min-width: 1400px) {
            .container {
                max-width: 1400px;
                padding: 40px;
            }
            
            .data-panel {
                gap: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒ å…‰çº¿å¼ºåº¦æ¢æµ‹å™¨ V2</h1>
        
        <div class="status-panel">
            <div><strong>è¿æ¥çŠ¶æ€:</strong> <span id="connectionStatus" style="color:red;">æœªè¿æ¥</span></div>
            <div><strong>æœ€æ–°å€¼:</strong> <span id="currentValue">-</span> ADC (<span id="currentVoltage">-</span> V)</div>
            <div><strong>å³°å€¼è®°å½•:</strong> æœ€å¤§ <span id="maxValue">-</span> | æœ€å° <span id="minValue">-</span></div>
            <div><strong>åˆ·æ–°ç‡:</strong> <span id="updateInterval">-</span> ms | <strong>çŠ¶æ€:</strong> <span id="systemStatus">-</span></div>
        </div>

        <div class="control-panel">
            <h3>æ§åˆ¶é¢æ¿</h3>
            <div class="button-group">
                <button onclick="startStrobeDetection()">é¢‘é—ªæ£€æµ‹ (5ç§’)</button>
                <select onchange="setRate(this.value)">
                    <option value="200">200ms</option>
                    <option value="100" selected>100ms</option>
                    <option value="50">50ms</option>
                    <option value="20">20ms</option>
                </select>
                <button onclick="sendCommand('pause')">æš‚åœ</button>
                <button onclick="sendCommand('resume')">ç»§ç»­</button>
                <button onclick="sendCommand('reset_peaks')">é‡ç½®å³°å€¼</button>
                <button onclick="sendCommand('reboot')">é‡å¯è®¾å¤‡</button>
                <button onclick="sendCommand('display_off')">å…³é—­æ˜¾ç¤ºå™¨</button>
                <button onclick="sendCommand('display_on')">æ¢å¤æ˜¾ç¤º</button>
                <button onclick="downloadCSV()">ä¸‹è½½æ•°æ®</button>
            </div>
        </div>

        <div id="strobePanel" style="display: none;">
            <h3>ğŸ” é¢‘é—ªæ£€æµ‹è¿›è¡Œä¸­... <span id="countdown">5</span>ç§’</h3>
        </div>

        <div class="data-panel">
            <div class="chart-container">
                <h3>å®æ—¶å…‰ç…§æ›²çº¿</h3>
                <canvas id="lightChart"></canvas>
            </div>
            <div class="info-container">
                <h3>ç³»ç»Ÿä¿¡æ¯</h3>
                <div id="systemInfo">
                    <p>æœ€å¤§å³°å€¼æ—¶é—´: <span id="maxTime">-</span></p>
                    <p>æœ€å°å³°å€¼æ—¶é—´: <span id="minTime">-</span></p>
                    <p>æ•°æ®ç‚¹æ•°: <span id="dataPoints">0</span></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let lightChart;
        const chartData = {
            labels: [],
            values: []
        };
        const maxChartPoints = 100;
        let strobeCountdown;
        
        // WebSocketè¿æ¥
        let ws = null;
        let wsReconnectInterval = null;
        const WS_RECONNECT_DELAY = 3000; // 3ç§’åé‡è¿
        
        // æµè§ˆå™¨ç«¯æ•°æ®å­˜å‚¨ï¼ˆç”¨äºä¸‹è½½å’Œé¢‘é—ªæ£€æµ‹ï¼‰
        let clientDataStore = []; // å­˜å‚¨æ ¼å¼: {timestamp, value, voltage}
        let maxStoredPoints = 10000; // æœ€å¤šå­˜å‚¨10000ä¸ªæ•°æ®ç‚¹
        
        // é¢‘é—ªæ£€æµ‹ç›¸å…³
        let strobeDetectionActive = false;
        let strobeDataCollection = [];
        let strobeStartTime = 0;
        let originalUpdateInterval = 100; // ä¿å­˜åŸå§‹åˆ·æ–°ç‡
        let isRestoringRate = false; // æ ‡è®°æ˜¯å¦æ­£åœ¨æ¢å¤åˆ·æ–°ç‡

        // åˆå§‹åŒ–å›¾è¡¨
        function initChart() {
            const ctx = document.getElementById('lightChart').getContext('2d');
            const isPortrait = window.matchMedia("(orientation: portrait)").matches;
            
            lightChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'å…‰çº¿å¼ºåº¦ (ADCå€¼)',
                        data: chartData.values,
                        borderColor: 'rgb(102, 126, 234)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        tension: 0.1,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: isPortrait ? 2 : 2,
                    animation: {
                        duration: 0 // ç¦ç”¨åŠ¨ç”»ä»¥æé«˜æ€§èƒ½
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'æ—¶é—´åºåˆ—', color: '#666' },
                            ticks: { maxTicksLimit: 10, color: '#666' },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        },
                        y: { 
                            title: { display: true, text: 'å…‰çº¿å¼ºåº¦ (ADC)', color: '#666' },
                            suggestedMin: 0,
                            suggestedMax: 4095,
                            ticks: { color: '#666' },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        }
                    }
                }
            });
            
            // ç›‘å¬å±å¹•æ–¹å‘å˜åŒ–ï¼Œé‡æ–°è°ƒæ•´å›¾è¡¨
            window.addEventListener('orientationchange', function() {
                setTimeout(() => {
                    if (lightChart) {
                        lightChart.resize();
                    }
                }, 100);
            });
            
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', function() {
                if (lightChart) {
                    lightChart.resize();
                }
            });
        }

        // è¿æ¥WebSocket
        function connectWebSocket() {
            // è·å–å½“å‰é¡µé¢çš„ä¸»æœºåå’Œç«¯å£
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname;
            const wsUrl = `${protocol}//${host}:81`;
            
            console.log('æ­£åœ¨è¿æ¥WebSocket:', wsUrl);
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    console.log('WebSocketè¿æ¥å·²å»ºç«‹');
                    document.getElementById('connectionStatus').textContent = 'å·²è¿æ¥ (WebSocket)';
                    document.getElementById('connectionStatus').style.color = 'green';
                    
                    // æ¸…é™¤é‡è¿å®šæ—¶å™¨
                    if (wsReconnectInterval) {
                        clearInterval(wsReconnectInterval);
                        wsReconnectInterval = null;
                    }
                };
                
                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // å¤„ç†ä¼ æ„Ÿå™¨æ•°æ®
                        if (data.type === 'sensor_data') {
                            updateDisplay(data);
                            storeClientData(data);
                            
                            // å¦‚æœé¢‘é—ªæ£€æµ‹æ¿€æ´»ï¼Œæ”¶é›†æ•°æ®
                            if (strobeDetectionActive) {
                                collectStrobeData(data);
                            }
                        }
                        // å¤„ç†å‘½ä»¤å“åº”
                        else if (data.status) {
                            console.log('å‘½ä»¤å“åº”:', data);
                            if (data.status === 'ok' && data.message) {
                                // å¯¹äºæŸäº›å‘½ä»¤ä¸æ˜¾ç¤ºalert
                                const command = data.command;
                                // é¢‘é—ªæ£€æµ‹æœŸé—´çš„set_rateå‘½ä»¤æˆ–æ­£åœ¨æ¢å¤åˆ·æ–°ç‡æ—¶ä¸æ˜¾ç¤ºæç¤º
                                if (command === 'set_rate' && (strobeDetectionActive || isRestoringRate)) {
                                    // é™é»˜å¤„ç†ï¼Œä¸æ˜¾ç¤ºæç¤º
                                    if (isRestoringRate) {
                                        isRestoringRate = false; // æ¸…é™¤æ ‡å¿—
                                    }
                                } else if (command !== 'display_off' && command !== 'display_on') {
                                    alert('æ‰§è¡Œç»“æœ: ' + data.message);
                                }
                            } else if (data.status === 'error') {
                                // é¢‘é—ªæ£€æµ‹æœŸé—´çš„set_rateå‘½ä»¤é”™è¯¯ä¹Ÿä¸æ˜¾ç¤ºæç¤º
                                const command = data.command;
                                if (!(command === 'set_rate' && (strobeDetectionActive || isRestoringRate))) {
                                    alert('é”™è¯¯: ' + data.message);
                                }
                                if (isRestoringRate) {
                                    isRestoringRate = false; // æ¸…é™¤æ ‡å¿—
                                }
                            }
                        }
                    } catch (error) {
                        console.error('è§£æWebSocketæ¶ˆæ¯å¤±è´¥:', error, event.data);
                    }
                };
                
                ws.onerror = function(error) {
                    console.error('WebSocketé”™è¯¯:', error);
                    document.getElementById('connectionStatus').textContent = 'è¿æ¥é”™è¯¯';
                    document.getElementById('connectionStatus').style.color = 'red';
                };
                
                ws.onclose = function() {
                    console.log('WebSocketè¿æ¥å·²å…³é—­');
                    document.getElementById('connectionStatus').textContent = 'è¿æ¥æ–­å¼€ï¼Œæ­£åœ¨é‡è¿...';
                    document.getElementById('connectionStatus').style.color = 'orange';
                    
                    // è‡ªåŠ¨é‡è¿
                    if (!wsReconnectInterval) {
                        wsReconnectInterval = setInterval(() => {
                            console.log('å°è¯•é‡æ–°è¿æ¥WebSocket...');
                            connectWebSocket();
                        }, WS_RECONNECT_DELAY);
                    }
                };
            } catch (error) {
                console.error('WebSocketè¿æ¥å¤±è´¥:', error);
                document.getElementById('connectionStatus').textContent = 'è¿æ¥å¤±è´¥: ' + error.message;
                document.getElementById('connectionStatus').style.color = 'red';
                
                // å°è¯•é‡è¿
                if (!wsReconnectInterval) {
                    wsReconnectInterval = setInterval(() => {
                        connectWebSocket();
                    }, WS_RECONNECT_DELAY);
                }
            }
        }

        // å­˜å‚¨æ•°æ®åˆ°å®¢æˆ·ç«¯
        function storeClientData(data) {
            const dataPoint = {
                timestamp: data.timestamp || Date.now(),
                value: data.value,
                voltage: data.voltage,
                uptime: data.uptime || 0
            };
            
            clientDataStore.push(dataPoint);
            
            // é™åˆ¶å­˜å‚¨æ•°é‡
            if (clientDataStore.length > maxStoredPoints) {
                clientDataStore.shift();
            }
        }

        // æ›´æ–°æ˜¾ç¤º
        function updateDisplay(data) {
            document.getElementById('currentValue').textContent = data.value;
            document.getElementById('currentVoltage').textContent = data.voltage.toFixed(3);
            document.getElementById('maxValue').textContent = data.max;
            document.getElementById('minValue').textContent = data.min;
            document.getElementById('updateInterval').textContent = data.interval;
            document.getElementById('systemStatus').textContent = data.paused ? 'å·²æš‚åœ' : 'è¿è¡Œä¸­';
            
            // æ›´æ–°ä¿å­˜çš„åˆ·æ–°ç‡ï¼ˆå¦‚æœä¸æ˜¯åœ¨é¢‘é—ªæ£€æµ‹ä¸­ï¼‰
            if (!strobeDetectionActive) {
                originalUpdateInterval = data.interval;
            }
            
            // æ›´æ–°å³°å€¼æ—¶é—´æ˜¾ç¤ºï¼ˆESP32è¿”å›çš„æ˜¯è¿è¡Œæ—¶é—´ï¼Œå•ä½æ¯«ç§’ï¼‰
            if (data.max_time) {
                const maxSeconds = Math.floor(data.max_time / 1000);
                const maxMinutes = Math.floor(maxSeconds / 60);
                const maxSecs = maxSeconds % 60;
                document.getElementById('maxTime').textContent = maxMinutes + 'åˆ†' + maxSecs + 'ç§’';
            }
            if (data.min_time) {
                const minSeconds = Math.floor(data.min_time / 1000);
                const minMinutes = Math.floor(minSeconds / 60);
                const minSecs = minSeconds % 60;
                document.getElementById('minTime').textContent = minMinutes + 'åˆ†' + minSecs + 'ç§’';
            }
            
            // æ›´æ–°å›¾è¡¨
            const timeLabel = new Date().toLocaleTimeString();
            chartData.labels.push(timeLabel);
            chartData.values.push(data.value);
            
            if (chartData.labels.length > maxChartPoints) {
                chartData.labels.shift();
                chartData.values.shift();
            }
            
            // ä½¿ç”¨ 'none' æ¨¡å¼æ›´æ–°å›¾è¡¨ä»¥æé«˜æ€§èƒ½
            lightChart.update('none');
            document.getElementById('dataPoints').textContent = clientDataStore.length;
        }

        // å‘é€æ§åˆ¶å‘½ä»¤ï¼ˆé€šè¿‡WebSocketï¼‰
        function sendCommand(command, value = '', silent = false) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                if (!silent) {
                    alert('WebSocketæœªè¿æ¥ï¼Œæ— æ³•å‘é€å‘½ä»¤');
                }
                return;
            }
            
            const commandData = {
                command: command,
                value: value
            };
            
            try {
                ws.send(JSON.stringify(commandData));
                console.log('å‘é€å‘½ä»¤:', commandData);
            } catch (error) {
                console.error('å‘é€å‘½ä»¤å¤±è´¥:', error);
                if (!silent) {
                    alert('å‘½ä»¤å‘é€å¤±è´¥: ' + error.message);
                }
            }
        }

        // è®¾ç½®åˆ·æ–°ç‡
        function setRate(rate) {
            sendCommand('set_rate', rate);
        }

        // é¢‘é—ªæ£€æµ‹ - æµè§ˆå™¨ç«¯å®ç°
        function startStrobeDetection() {
            // ä¿å­˜å½“å‰åˆ·æ–°ç‡å¹¶è®¾ç½®ä¸º20msï¼ˆé™é»˜æ¨¡å¼ï¼Œä¸æ˜¾ç¤ºæç¤ºï¼‰
            originalUpdateInterval = parseInt(document.getElementById('updateInterval').textContent) || 100;
            sendCommand('set_rate', '20', true); // silent = true
            
            strobeDetectionActive = true;
            strobeDataCollection = [];
            strobeStartTime = Date.now();
            
            document.getElementById('strobePanel').style.display = 'block';
            document.getElementById('strobePanel').innerHTML = '<h3>ğŸ” é¢‘é—ªæ£€æµ‹è¿›è¡Œä¸­... <span id="countdown">5</span>ç§’</h3>';
            let timeLeft = 5;
            
            strobeCountdown = setInterval(() => {
                document.getElementById('countdown').textContent = timeLeft;
                timeLeft--;
                
                if (timeLeft < 0) {
                    clearInterval(strobeCountdown);
                    strobeDetectionActive = false;
                    
                    // æ¢å¤åŸå§‹åˆ·æ–°ç‡ï¼ˆé™é»˜æ¨¡å¼ï¼Œä¸æ˜¾ç¤ºæç¤ºï¼‰
                    isRestoringRate = true; // è®¾ç½®æ ‡å¿—ï¼Œé¿å…æ˜¾ç¤ºæç¤º
                    sendCommand('set_rate', originalUpdateInterval.toString(), true);
                    
                    // åœ¨æµè§ˆå™¨ç«¯åˆ†ææ•°æ®
                    const result = analyzeStrobeData();
                    document.getElementById('strobePanel').innerHTML = 
                        '<h3>ğŸ” é¢‘é—ªæ£€æµ‹ç»“æœ</h3><p style="font-size:16px; font-weight:bold;">' + result + '</p>';
                    // ä¸å†éšè—ç»“æœï¼Œä¿æŒæ˜¾ç¤º
                }
            }, 1000);
        }

        // æ”¶é›†é¢‘é—ªæ£€æµ‹æ•°æ®
        function collectStrobeData(data) {
            strobeDataCollection.push({
                timestamp: data.timestamp || Date.now(),
                value: data.value,
                voltage: data.voltage
            });
        }

        // ========== é«˜çº§é¢‘é—ªæ£€æµ‹ç®—æ³•ï¼ˆåŸºäºæ–‡æ¡£ç®—æ³•ï¼‰ ==========
        
        // 1. ä¸­å€¼æ»¤æ³¢
        function medianFilter(input, windowSize) {
            const n = input.length;
            const output = new Array(n);
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(n - 1, i + halfWindow);
                const window = [];
                
                for (let j = start; j <= end; j++) {
                    window.push(input[j]);
                }
                
                // æ’åºæ‰¾ä¸­å€¼
                window.sort((a, b) => a - b);
                output[i] = window[Math.floor(window.length / 2)];
            }
            
            return output;
        }
        
        // 2. ç§»åŠ¨å¹³å‡æ»¤æ³¢
        function movingAverage(input, windowSize) {
            const n = input.length;
            const output = new Array(n);
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(n - 1, i + halfWindow);
                let sum = 0;
                let count = 0;
                
                for (let j = start; j <= end; j++) {
                    sum += input[j];
                    count++;
                }
                
                output[i] = sum / count;
            }
            
            return output;
        }
        
        // 3. è®¡ç®—ç»Ÿè®¡ç‰¹å¾
        function calculateStatistics(data) {
            const n = data.length;
            if (n === 0) {
                return { mean: 0, variance: 0, stdDev: 0, range: 0, max: 0, min: 0 };
            }
            
            let sum = 0;
            let sumSq = 0;
            let max = data[0];
            let min = data[0];
            
            for (let i = 0; i < n; i++) {
                sum += data[i];
                sumSq += data[i] * data[i];
                if (data[i] > max) max = data[i];
                if (data[i] < min) min = data[i];
            }
            
            const mean = sum / n;
            const variance = (sumSq / n) - (mean * mean);
            const stdDev = Math.sqrt(Math.max(0, variance));
            const range = max - min;
            
            return { mean, variance, stdDev, range, max, min };
        }
        
        // 4. è‡ªç›¸å…³å‡½æ•°è®¡ç®—
        function calculateAutocorrelation(data, lag) {
            const n = data.length;
            if (lag <= 0 || lag >= n || n <= 1) return 0.0;
            
            let mean = 0;
            for (let i = 0; i < n; i++) {
                mean += data[i];
            }
            mean /= n;
            
            let numerator = 0;
            let denominator = 0;
            
            for (let i = 0; i < n - lag; i++) {
                numerator += (data[i] - mean) * (data[i + lag] - mean);
            }
            
            for (let i = 0; i < n; i++) {
                denominator += (data[i] - mean) * (data[i] - mean);
            }
            
            if (denominator === 0) return 0.0;
            return numerator / denominator;
        }
        
        // 5. å³°å€¼æ£€æµ‹
        function findPeaks(data, threshold) {
            const peaks = { positions: [], values: [] };
            const n = data.length;
            
            for (let i = 1; i < n - 1; i++) {
                if (data[i] > data[i - 1] && data[i] > data[i + 1] && data[i] > threshold) {
                    peaks.positions.push(i);
                    peaks.values.push(data[i]);
                }
            }
            
            return peaks;
        }
        
        // 6. è®¡ç®—è§„å¾‹æ€§è¯„åˆ†ï¼ˆåŸºäºå³°å€¼é—´éš”çš„å˜å¼‚ç³»æ•°ï¼‰
        function calculateRegularityScore(data, peaks) {
            if (peaks.positions.length < 3) return 0.0;
            
            let sumIntervals = 0;
            let sumSqIntervals = 0;
            
            for (let i = 1; i < peaks.positions.length; i++) {
                const interval = peaks.positions[i] - peaks.positions[i - 1];
                sumIntervals += interval;
                sumSqIntervals += interval * interval;
            }
            
            const meanInterval = sumIntervals / (peaks.positions.length - 1);
            const variance = (sumSqIntervals / (peaks.positions.length - 1)) - (meanInterval * meanInterval);
            
            if (meanInterval === 0) return 0.0;
            
            const cv = Math.sqrt(Math.abs(variance)) / meanInterval;
            const score = 1.0 - cv;
            return Math.max(0.0, score);
        }
        
        // 7. ä¸»æ£€æµ‹å‡½æ•°ï¼ˆåŸºäºæ–‡æ¡£ç®—æ³•ï¼‰
        function analyzeStrobeData() {
            const SMOOTH_WINDOW = 5;
            const MIN_PERIODIC_POINTS = 10;
            const MAX_PERIODIC_POINTS = 200;
            
            if (strobeDataCollection.length < 10) {
                return 'æ£€æµ‹å¤±è´¥ï¼šæ•°æ®ç‚¹ä¸è¶³ (ä»…æ”¶é›†åˆ° ' + strobeDataCollection.length + ' ä¸ªæ•°æ®ç‚¹)';
            }
            
            // æå–åŸå§‹æ•°æ®
            const rawData = strobeDataCollection.map(d => d.value);
            const n = rawData.length;
            
            // é˜¶æ®µä¸€ï¼šæ•°æ®é¢„å¤„ç†
            const medianFiltered = medianFilter(rawData, SMOOTH_WINDOW);
            const smoothed = movingAverage(medianFiltered, SMOOTH_WINDOW);
            
            // é˜¶æ®µäºŒï¼šç»Ÿè®¡ç‰¹å¾æå–
            const stats = calculateStatistics(smoothed);
            
            // é˜¶æ®µä¸‰ï¼šç¨³å®šæ€§åˆ¤æ–­ï¼ˆæ— é¢‘é—ªï¼‰
            const stabilityThreshold = Math.max(stats.mean * 0.01, 0.001);
            
            if (stats.stdDev < stabilityThreshold && stats.range < stabilityThreshold * 10) {
                const confidence = Math.max(0, Math.min(1, 1.0 - (stats.stdDev / (stabilityThreshold + 0.0001))));
                return `æœªå‘ç°æ˜æ˜¾é¢‘é—ªï¼šæ•°å€¼å‡ ä¹æ— å˜åŒ– (æ ‡å‡†å·®: ${stats.stdDev.toFixed(2)}, èŒƒå›´: ${stats.range.toFixed(2)}, ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(1)}%, æ•°æ®ç‚¹: ${n})`;
            }
            
            // é˜¶æ®µå››ï¼šå‘¨æœŸæ€§æ£€æµ‹ï¼ˆè‡ªç›¸å…³åˆ†æï¼‰
            let maxLag = Math.floor(n / 4.0);
            maxLag = Math.max(MIN_PERIODIC_POINTS, Math.min(MAX_PERIODIC_POINTS, maxLag));
            maxLag = Math.min(maxLag, n - 1);
            
            let significantPeaks = 0;
            let maxAutocorr = 0;
            let bestLag = 0;
            
            for (let lag = 1; lag < maxLag; lag++) {
                const ac = calculateAutocorrelation(smoothed, lag);
                const absAc = Math.abs(ac);
                if (absAc > 0.3) {
                    significantPeaks++;
                }
                if (absAc > maxAutocorr) {
                    maxAutocorr = absAc;
                    bestLag = lag;
                }
            }
            
            const periodicScore = significantPeaks / maxLag;
            
            // é˜¶æ®µäº”ï¼šå³°å€¼æ£€æµ‹å’Œè§„å¾‹æ€§åˆ†æ
            const peakThreshold = stats.mean + stats.stdDev * 0.5;
            const peaks = findPeaks(smoothed, peakThreshold);
            const regularityScore = calculateRegularityScore(smoothed, peaks);
            
            // é˜¶æ®µå…­ï¼šç»¼åˆåˆ¤æ–­
            const amplitudeScore = stats.mean > 0 ? (stats.stdDev / stats.mean) : 0.0;
            
            // åˆ¤æ–­1ï¼šå­˜åœ¨æ˜æ˜¾é¢‘é—ªï¼ˆå‘¨æœŸæ€§ + è§„å¾‹æ€§ï¼‰
            if (peaks.positions.length >= 3 && regularityScore > 0.7 && periodicScore > 0.1) {
                const confidence = (regularityScore + periodicScore) / 2.0;
                return `å­˜åœ¨é¢‘é—ªï¼šæ£€æµ‹åˆ°å‘¨æœŸæ€§æ³¢åŠ¨ (è§„å¾‹æ€§: ${(regularityScore * 100).toFixed(1)}%, å‘¨æœŸæ€§: ${(periodicScore * 100).toFixed(1)}%, ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(1)}%, å³°å€¼æ•°: ${peaks.positions.length}, æ•°æ®ç‚¹: ${n})`;
            }
            
            // åˆ¤æ–­2ï¼šæ•°æ®æºæ±¡æŸ“ï¼ˆæ— è§„åˆ™å˜åŒ–æˆ–å¤§å¹…åº¦å˜åŒ–ï¼‰
            if (amplitudeScore > 0.5 || peaks.positions.length < 2) {
                return `âš ï¸ æ•°æ®æºæ±¡æŸ“ï¼šæ£€æµ‹åˆ°æ— è§„åˆ™å˜åŒ–æˆ–å¤§å¹…åº¦å˜åŒ–ï¼Œæ— æ³•åˆ¤æ–­æ˜¯å¦é¢‘é—ªã€‚è¯·ç¡®ä¿æµ‹è¯•ç¯å¢ƒç¨³å®šï¼Œé¿å…å…‰æºç§»åŠ¨æˆ–é®æŒ¡ã€‚ (å¹…åº¦æ¯”: ${(amplitudeScore * 100).toFixed(1)}%, å³°å€¼æ•°: ${peaks.positions.length}, æ ‡å‡†å·®: ${stats.stdDev.toFixed(2)}, æ•°æ®ç‚¹: ${n})`;
            }
            
            // åˆ¤æ–­3ï¼šæ•°æ®æºæ±¡æŸ“ï¼ˆæ³¢åŠ¨ä¸è§„åˆ™ï¼‰
            if (regularityScore < 0.3) {
                return `âš ï¸ æ•°æ®æºæ±¡æŸ“ï¼šæ³¢åŠ¨ä¸è§„åˆ™ï¼Œå¯èƒ½æ˜¯å› ç§»åŠ¨æˆ–æ‰‹æŠ–å¯¼è‡´ã€‚è¯·ç¡®ä¿æµ‹è¯•ç¯å¢ƒç¨³å®šã€‚ (è§„å¾‹æ€§: ${(regularityScore * 100).toFixed(1)}%, æ ‡å‡†å·®: ${stats.stdDev.toFixed(2)}, æ•°æ®ç‚¹: ${n})`;
            }
            
            // åˆ¤æ–­4ï¼šæœªå‘ç°æ˜æ˜¾é¢‘é—ª
            return `æœªå‘ç°æ˜æ˜¾é¢‘é—ª (è§„å¾‹æ€§: ${(regularityScore * 100).toFixed(1)}%, å‘¨æœŸæ€§: ${(periodicScore * 100).toFixed(1)}%, æ ‡å‡†å·®: ${stats.stdDev.toFixed(2)}, æ•°æ®ç‚¹: ${n})`;
        }

        // ä¸‹è½½æ•°æ® - ä»æµè§ˆå™¨ç«¯å­˜å‚¨ä¸‹è½½
        function downloadCSV() {
            if (clientDataStore.length === 0) {
                alert('æ²¡æœ‰å¯ä¸‹è½½çš„æ•°æ®ï¼Œè¯·ç­‰å¾…æ•°æ®åŒæ­¥');
                return;
            }
            
            try {
                let csvData = 'æ—¶é—´æˆ³,æœ¬åœ°æ—¶é—´,ADCå€¼,ç”µå‹(V),ESP32è¿è¡Œæ—¶é—´(ms)\n';
                
                for (let i = 0; i < clientDataStore.length; i++) {
                    const point = clientDataStore[i];
                    const date = new Date(point.timestamp);
                    csvData += point.timestamp + ',';
                    csvData += date.toLocaleString() + ',';
                    csvData += point.value + ',';
                    csvData += point.voltage.toFixed(3) + ',';
                    csvData += (point.uptime || 0) + '\n';
                }
                
                const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `light_sensor_data_${new Date().getTime()}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                alert(`æ•°æ®ä¸‹è½½æˆåŠŸï¼å…± ${clientDataStore.length} ä¸ªæ•°æ®ç‚¹`);
            } catch (error) {
                console.error('ä¸‹è½½å¤±è´¥:', error);
                alert('æ•°æ®ä¸‹è½½å¤±è´¥: ' + error.message);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = function() {
            initChart();
            // è¿æ¥WebSocket
            connectWebSocket();
        };
        
        // é¡µé¢å…³é—­æ—¶æ¸…ç†
        window.onbeforeunload = function() {
            if (ws) {
                ws.close();
            }
            if (wsReconnectInterval) {
                clearInterval(wsReconnectInterval);
            }
        };
    </script>
</body>
</html>

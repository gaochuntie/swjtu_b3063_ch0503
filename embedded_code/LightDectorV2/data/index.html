<!DOCTYPE html>
<html>
<head>
    <title>å…‰çº¿å¼ºåº¦æ¢æµ‹å™¨ V2</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif; 
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        h1 { 
            color: #333; 
            margin: 0 0 20px 0;
            font-size: 1.8em;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2, h3 { 
            color: #444; 
            margin-top: 0;
        }
        
        .status-panel { 
            background: linear-gradient(135deg, #e8f4fd 0%, #d1e7f7 100%);
            padding: 15px; 
            margin: 15px 0;
            border-radius: 10px;
            border-left: 5px solid #2196F3;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .status-panel div {
            margin: 8px 0;
            font-size: 0.95em;
        }
        
        .status-panel strong {
            color: #1976D2;
            margin-right: 5px;
        }
        
        .control-panel { 
            margin: 20px 0; 
            padding: 20px; 
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: linear-gradient(135deg, #f9f9f9 0%, #f5f5f5 100%);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-panel h3 {
            margin-top: 0;
            color: #555;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        button, select { 
            margin: 0;
            padding: 10px 18px; 
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button:hover { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        select {
            background: white;
            cursor: pointer;
        }
        
        select:hover {
            border-color: #667eea;
        }
        
        #strobePanel {
            display: none;
            background: linear-gradient(135deg, #fffacd 0%, #fff8dc 100%);
            padding: 15px;
            margin: 15px 0;
            border-radius: 10px;
            border-left: 5px solid #ffd700;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        #strobePanel h3 {
            margin: 0;
            color: #8b6914;
        }
        
        .data-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .chart-container {
            background: #fafafa;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .chart-container h3 {
            margin-top: 0;
            color: #555;
        }
        
        .info-container {
            background: #fafafa;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .info-container h3 {
            margin-top: 0;
            color: #555;
        }
        
        #systemInfo p {
            margin: 12px 0;
            padding: 8px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }
        
        /* æ¨ªå±è®¾å¤‡ï¼ˆPCå’Œæ¨ªå±ç§»åŠ¨è®¾å¤‡ï¼‰ */
        @media (orientation: landscape) and (min-width: 768px) {
            body {
                padding: 20px;
            }
            
            .container {
                padding: 30px;
            }
            
            .data-panel {
                grid-template-columns: 2fr 1fr;
            }
            
            .button-group {
                gap: 10px;
            }
        }
        
        /* ç«–å±è®¾å¤‡ï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰ */
        @media (orientation: portrait) {
            body {
                padding: 8px;
            }
            
            .container {
                padding: 15px;
                border-radius: 12px;
            }
            
            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }
            
            .status-panel {
                padding: 12px;
                font-size: 0.9em;
            }
            
            .control-panel {
                padding: 15px;
            }
            
            .button-group {
                gap: 6px;
            }
            
            button, select {
                padding: 8px 12px;
                font-size: 0.85em;
                flex: 1 1 auto;
                min-width: calc(50% - 3px);
            }
            
            .data-panel {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            /* ç«–å±æ—¶ï¼Œæ›²çº¿å›¾æ”¾åœ¨ä¸‹éƒ¨å¹¶å æ»¡å®½åº¦ */
            .data-panel {
                display: flex;
                flex-direction: column;
            }
            
            .info-container {
                order: 1;
            }
            
            .chart-container {
                order: 2;
                width: 100%;
            }
            
            .chart-container canvas {
                width: 100% !important;
                height: auto !important;
            }
        }
        
        /* å°å±å¹•è®¾å¤‡ä¼˜åŒ– */
        @media (max-width: 480px) {
            h1 {
                font-size: 1.3em;
            }
            
            .status-panel div {
                font-size: 0.85em;
            }
            
            button, select {
                font-size: 0.8em;
                padding: 7px 10px;
                min-width: calc(50% - 3px);
            }
            
            .chart-container, .info-container {
                padding: 12px;
            }
        }
        
        /* å¤§å±å¹•è®¾å¤‡ä¼˜åŒ– */
        @media (min-width: 1400px) {
            .container {
                max-width: 1400px;
                padding: 40px;
            }
            
            .data-panel {
                gap: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒ å…‰çº¿å¼ºåº¦æ¢æµ‹å™¨ V2</h1>
        
        <div class="status-panel">
            <div><strong>è¿æ¥çŠ¶æ€:</strong> <span id="connectionStatus" style="color:red;">æœªè¿æ¥</span></div>
            <div><strong>æœ€æ–°å€¼:</strong> <span id="currentValue">-</span> ADC (<span id="currentVoltage">-</span> V)</div>
            <div><strong>å³°å€¼è®°å½•:</strong> æœ€å¤§ <span id="maxValue">-</span> | æœ€å° <span id="minValue">-</span></div>
            <div><strong>åˆ·æ–°ç‡:</strong> <span id="updateInterval">-</span> ms | <strong>çŠ¶æ€:</strong> <span id="systemStatus">-</span></div>
        </div>

        <div class="control-panel">
            <h3>æ§åˆ¶é¢æ¿</h3>
            <div class="button-group">
                <button onclick="startStrobeDetection()">é¢‘é—ªæ£€æµ‹ (5ç§’)</button>
                <select onchange="setRate(this.value)">
                    <option value="200">200ms</option>
                    <option value="100" selected>100ms</option>
                    <option value="50">50ms</option>
                    <option value="20">20ms</option>
                </select>
                <button onclick="sendCommand('pause')">æš‚åœ</button>
                <button onclick="sendCommand('resume')">ç»§ç»­</button>
                <button onclick="sendCommand('reset_peaks')">é‡ç½®å³°å€¼</button>
                <button onclick="sendCommand('reboot')">é‡å¯è®¾å¤‡</button>
                <button onclick="sendCommand('display_off')">å…³é—­æ˜¾ç¤ºå™¨</button>
                <button onclick="sendCommand('display_on')">æ¢å¤æ˜¾ç¤º</button>
                <button onclick="downloadCSV()">ä¸‹è½½æ•°æ®</button>
            </div>
        </div>

        <div id="strobePanel" style="display: none;">
            <h3>ğŸ” é¢‘é—ªæ£€æµ‹è¿›è¡Œä¸­... <span id="countdown">5</span>ç§’</h3>
        </div>

        <div class="data-panel">
            <div class="chart-container">
                <h3>å®æ—¶å…‰ç…§æ›²çº¿</h3>
                <canvas id="lightChart"></canvas>
            </div>
            <div class="info-container">
                <h3>ç³»ç»Ÿä¿¡æ¯</h3>
                <div id="systemInfo">
                    <p>æœ€å¤§å³°å€¼æ—¶é—´: <span id="maxTime">-</span></p>
                    <p>æœ€å°å³°å€¼æ—¶é—´: <span id="minTime">-</span></p>
                    <p>æ•°æ®ç‚¹æ•°: <span id="dataPoints">0</span></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let lightChart;
        const chartData = {
            labels: [],
            values: []
        };
        const maxChartPoints = 100;
        let strobeCountdown;
        
        // WebSocketè¿æ¥
        let ws = null;
        let wsReconnectInterval = null;
        const WS_RECONNECT_DELAY = 3000; // 3ç§’åé‡è¿
        
        // æµè§ˆå™¨ç«¯æ•°æ®å­˜å‚¨ï¼ˆç”¨äºä¸‹è½½å’Œé¢‘é—ªæ£€æµ‹ï¼‰
        let clientDataStore = []; // å­˜å‚¨æ ¼å¼: {timestamp, value, voltage}
        let maxStoredPoints = 10000; // æœ€å¤šå­˜å‚¨10000ä¸ªæ•°æ®ç‚¹
        
        // é¢‘é—ªæ£€æµ‹ç›¸å…³
        let strobeDetectionActive = false;
        let strobeDataCollection = [];
        let strobeStartTime = 0;
        let originalUpdateInterval = 100; // ä¿å­˜åŸå§‹åˆ·æ–°ç‡
        let isRestoringRate = false; // æ ‡è®°æ˜¯å¦æ­£åœ¨æ¢å¤åˆ·æ–°ç‡

        // åˆå§‹åŒ–å›¾è¡¨
        function initChart() {
            const ctx = document.getElementById('lightChart').getContext('2d');
            const isPortrait = window.matchMedia("(orientation: portrait)").matches;
            
            lightChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'å…‰çº¿å¼ºåº¦ (ADCå€¼)',
                        data: chartData.values,
                        borderColor: 'rgb(102, 126, 234)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        tension: 0.1,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: isPortrait ? 2 : 2,
                    animation: {
                        duration: 0 // ç¦ç”¨åŠ¨ç”»ä»¥æé«˜æ€§èƒ½
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'æ—¶é—´åºåˆ—', color: '#666' },
                            ticks: { maxTicksLimit: 10, color: '#666' },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        },
                        y: { 
                            title: { display: true, text: 'å…‰çº¿å¼ºåº¦ (ADC)', color: '#666' },
                            suggestedMin: 0,
                            suggestedMax: 4095,
                            ticks: { color: '#666' },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        }
                    }
                }
            });
            
            // ç›‘å¬å±å¹•æ–¹å‘å˜åŒ–ï¼Œé‡æ–°è°ƒæ•´å›¾è¡¨
            window.addEventListener('orientationchange', function() {
                setTimeout(() => {
                    if (lightChart) {
                        lightChart.resize();
                    }
                }, 100);
            });
            
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', function() {
                if (lightChart) {
                    lightChart.resize();
                }
            });
        }

        // è¿æ¥WebSocket
        function connectWebSocket() {
            // è·å–å½“å‰é¡µé¢çš„ä¸»æœºåå’Œç«¯å£
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname;
            const wsUrl = `${protocol}//${host}:81`;
            
            console.log('æ­£åœ¨è¿æ¥WebSocket:', wsUrl);
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    console.log('WebSocketè¿æ¥å·²å»ºç«‹');
                    document.getElementById('connectionStatus').textContent = 'å·²è¿æ¥ (WebSocket)';
                    document.getElementById('connectionStatus').style.color = 'green';
                    
                    // æ¸…é™¤é‡è¿å®šæ—¶å™¨
                    if (wsReconnectInterval) {
                        clearInterval(wsReconnectInterval);
                        wsReconnectInterval = null;
                    }
                };
                
                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // å¤„ç†ä¼ æ„Ÿå™¨æ•°æ®
                        if (data.type === 'sensor_data') {
                            updateDisplay(data);
                            storeClientData(data);
                            
                            // å¦‚æœé¢‘é—ªæ£€æµ‹æ¿€æ´»ï¼Œæ”¶é›†æ•°æ®
                            if (strobeDetectionActive) {
                                collectStrobeData(data);
                            }
                        }
                        // å¤„ç†å‘½ä»¤å“åº”
                        else if (data.status) {
                            console.log('å‘½ä»¤å“åº”:', data);
                            if (data.status === 'ok' && data.message) {
                                // å¯¹äºæŸäº›å‘½ä»¤ä¸æ˜¾ç¤ºalert
                                const command = data.command;
                                // é¢‘é—ªæ£€æµ‹æœŸé—´çš„set_rateå‘½ä»¤æˆ–æ­£åœ¨æ¢å¤åˆ·æ–°ç‡æ—¶ä¸æ˜¾ç¤ºæç¤º
                                if (command === 'set_rate' && (strobeDetectionActive || isRestoringRate)) {
                                    // é™é»˜å¤„ç†ï¼Œä¸æ˜¾ç¤ºæç¤º
                                    if (isRestoringRate) {
                                        isRestoringRate = false; // æ¸…é™¤æ ‡å¿—
                                    }
                                } else if (command !== 'display_off' && command !== 'display_on') {
                                    alert('æ‰§è¡Œç»“æœ: ' + data.message);
                                }
                            } else if (data.status === 'error') {
                                // é¢‘é—ªæ£€æµ‹æœŸé—´çš„set_rateå‘½ä»¤é”™è¯¯ä¹Ÿä¸æ˜¾ç¤ºæç¤º
                                const command = data.command;
                                if (!(command === 'set_rate' && (strobeDetectionActive || isRestoringRate))) {
                                    alert('é”™è¯¯: ' + data.message);
                                }
                                if (isRestoringRate) {
                                    isRestoringRate = false; // æ¸…é™¤æ ‡å¿—
                                }
                            }
                        }
                    } catch (error) {
                        console.error('è§£æWebSocketæ¶ˆæ¯å¤±è´¥:', error, event.data);
                    }
                };
                
                ws.onerror = function(error) {
                    console.error('WebSocketé”™è¯¯:', error);
                    document.getElementById('connectionStatus').textContent = 'è¿æ¥é”™è¯¯';
                    document.getElementById('connectionStatus').style.color = 'red';
                };
                
                ws.onclose = function() {
                    console.log('WebSocketè¿æ¥å·²å…³é—­');
                    document.getElementById('connectionStatus').textContent = 'è¿æ¥æ–­å¼€ï¼Œæ­£åœ¨é‡è¿...';
                    document.getElementById('connectionStatus').style.color = 'orange';
                    
                    // è‡ªåŠ¨é‡è¿
                    if (!wsReconnectInterval) {
                        wsReconnectInterval = setInterval(() => {
                            console.log('å°è¯•é‡æ–°è¿æ¥WebSocket...');
                            connectWebSocket();
                        }, WS_RECONNECT_DELAY);
                    }
                };
            } catch (error) {
                console.error('WebSocketè¿æ¥å¤±è´¥:', error);
                document.getElementById('connectionStatus').textContent = 'è¿æ¥å¤±è´¥: ' + error.message;
                document.getElementById('connectionStatus').style.color = 'red';
                
                // å°è¯•é‡è¿
                if (!wsReconnectInterval) {
                    wsReconnectInterval = setInterval(() => {
                        connectWebSocket();
                    }, WS_RECONNECT_DELAY);
                }
            }
        }

        // å­˜å‚¨æ•°æ®åˆ°å®¢æˆ·ç«¯
        function storeClientData(data) {
            const dataPoint = {
                timestamp: data.timestamp || Date.now(),
                value: data.value,
                voltage: data.voltage,
                uptime: data.uptime || 0
            };
            
            clientDataStore.push(dataPoint);
            
            // é™åˆ¶å­˜å‚¨æ•°é‡
            if (clientDataStore.length > maxStoredPoints) {
                clientDataStore.shift();
            }
        }

        // æ›´æ–°æ˜¾ç¤º
        function updateDisplay(data) {
            document.getElementById('currentValue').textContent = data.value;
            document.getElementById('currentVoltage').textContent = data.voltage.toFixed(3);
            document.getElementById('maxValue').textContent = data.max;
            document.getElementById('minValue').textContent = data.min;
            document.getElementById('updateInterval').textContent = data.interval;
            document.getElementById('systemStatus').textContent = data.paused ? 'å·²æš‚åœ' : 'è¿è¡Œä¸­';
            
            // æ›´æ–°ä¿å­˜çš„åˆ·æ–°ç‡ï¼ˆå¦‚æœä¸æ˜¯åœ¨é¢‘é—ªæ£€æµ‹ä¸­ï¼‰
            if (!strobeDetectionActive) {
                originalUpdateInterval = data.interval;
            }
            
            // æ›´æ–°å³°å€¼æ—¶é—´æ˜¾ç¤ºï¼ˆESP32è¿”å›çš„æ˜¯è¿è¡Œæ—¶é—´ï¼Œå•ä½æ¯«ç§’ï¼‰
            if (data.max_time) {
                const maxSeconds = Math.floor(data.max_time / 1000);
                const maxMinutes = Math.floor(maxSeconds / 60);
                const maxSecs = maxSeconds % 60;
                document.getElementById('maxTime').textContent = maxMinutes + 'åˆ†' + maxSecs + 'ç§’';
            }
            if (data.min_time) {
                const minSeconds = Math.floor(data.min_time / 1000);
                const minMinutes = Math.floor(minSeconds / 60);
                const minSecs = minSeconds % 60;
                document.getElementById('minTime').textContent = minMinutes + 'åˆ†' + minSecs + 'ç§’';
            }
            
            // æ›´æ–°å›¾è¡¨
            const timeLabel = new Date().toLocaleTimeString();
            chartData.labels.push(timeLabel);
            chartData.values.push(data.value);
            
            if (chartData.labels.length > maxChartPoints) {
                chartData.labels.shift();
                chartData.values.shift();
            }
            
            // ä½¿ç”¨ 'none' æ¨¡å¼æ›´æ–°å›¾è¡¨ä»¥æé«˜æ€§èƒ½
            lightChart.update('none');
            document.getElementById('dataPoints').textContent = clientDataStore.length;
        }

        // å‘é€æ§åˆ¶å‘½ä»¤ï¼ˆé€šè¿‡WebSocketï¼‰
        function sendCommand(command, value = '', silent = false) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                if (!silent) {
                    alert('WebSocketæœªè¿æ¥ï¼Œæ— æ³•å‘é€å‘½ä»¤');
                }
                return;
            }
            
            const commandData = {
                command: command,
                value: value
            };
            
            try {
                ws.send(JSON.stringify(commandData));
                console.log('å‘é€å‘½ä»¤:', commandData);
            } catch (error) {
                console.error('å‘é€å‘½ä»¤å¤±è´¥:', error);
                if (!silent) {
                    alert('å‘½ä»¤å‘é€å¤±è´¥: ' + error.message);
                }
            }
        }

        // è®¾ç½®åˆ·æ–°ç‡
        function setRate(rate) {
            sendCommand('set_rate', rate);
        }

        // é¢‘é—ªæ£€æµ‹ - æµè§ˆå™¨ç«¯å®ç°
        function startStrobeDetection() {
            // ä¿å­˜å½“å‰åˆ·æ–°ç‡å¹¶è®¾ç½®ä¸º20msï¼ˆé™é»˜æ¨¡å¼ï¼Œä¸æ˜¾ç¤ºæç¤ºï¼‰
            originalUpdateInterval = parseInt(document.getElementById('updateInterval').textContent) || 100;
            sendCommand('set_rate', '20', true); // silent = true
            
            strobeDetectionActive = true;
            strobeDataCollection = [];
            strobeStartTime = Date.now();
            
            document.getElementById('strobePanel').style.display = 'block';
            document.getElementById('strobePanel').innerHTML = '<h3>ğŸ” é¢‘é—ªæ£€æµ‹è¿›è¡Œä¸­... <span id="countdown">5</span>ç§’</h3>';
            let timeLeft = 5;
            
            strobeCountdown = setInterval(() => {
                document.getElementById('countdown').textContent = timeLeft;
                timeLeft--;
                
                if (timeLeft < 0) {
                    clearInterval(strobeCountdown);
                    strobeDetectionActive = false;
                    
                    // æ¢å¤åŸå§‹åˆ·æ–°ç‡ï¼ˆé™é»˜æ¨¡å¼ï¼Œä¸æ˜¾ç¤ºæç¤ºï¼‰
                    isRestoringRate = true; // è®¾ç½®æ ‡å¿—ï¼Œé¿å…æ˜¾ç¤ºæç¤º
                    sendCommand('set_rate', originalUpdateInterval.toString(), true);
                    
                    // åœ¨æµè§ˆå™¨ç«¯åˆ†ææ•°æ®
                    const result = analyzeStrobeData();
                    document.getElementById('strobePanel').innerHTML = 
                        '<h3>ğŸ” é¢‘é—ªæ£€æµ‹ç»“æœ</h3><p style="font-size:16px; font-weight:bold;">' + result + '</p>';
                    // ä¸å†éšè—ç»“æœï¼Œä¿æŒæ˜¾ç¤º
                }
            }, 1000);
        }

        // æ”¶é›†é¢‘é—ªæ£€æµ‹æ•°æ®
        function collectStrobeData(data) {
            strobeDataCollection.push({
                timestamp: data.timestamp || Date.now(),
                value: data.value,
                voltage: data.voltage
            });
        }

        // ========== ç®€æ´é¢‘é—ªæ£€æµ‹ç®—æ³•ï¼ˆæ–°æ€è·¯ï¼šä¼˜å…ˆå‡†ç¡®æ€§ï¼‰ ==========
        
        // 1. æ£€æµ‹å¼‚å¸¸çªå˜ï¼ˆåªæ£€æµ‹æç«¯å¼‚å¸¸ï¼Œéå¸¸å®½æ¾ï¼‰
        function detectAnomalies(data) {
            const anomalies = [];
            const n = data.length;
            if (n < 5) return anomalies;
            
            // åªæ£€æµ‹ä¸¤ç§æç«¯å¼‚å¸¸ï¼š
            // 1. è¶…å‡ºADCåˆç†èŒƒå›´çš„å€¼ï¼ˆ0-4095ï¼‰
            // 2. å®Œå…¨å­¤ç«‹çš„æç«¯å¼‚å¸¸å€¼ï¼ˆå‰åéƒ½æ˜¯æ­£å¸¸å€¼ï¼Œä¸­é—´çªç„¶å‡ºç°å®Œå…¨ä¸ç¬¦åˆä»»ä½•æ¨¡å¼çš„æç«¯å€¼ï¼‰
            
            // æ£€æµ‹è¶…å‡ºADCèŒƒå›´çš„å€¼
            for (let i = 0; i < n; i++) {
                if (data[i] < 0 || data[i] > 4095) {
                    anomalies.push({ index: i, change: Math.abs(data[i] - 2048) });
                }
            }
            
            // æ£€æµ‹å®Œå…¨å­¤ç«‹çš„æç«¯å¼‚å¸¸å€¼ï¼ˆéå¸¸ä¸¥æ ¼çš„åˆ¤æ–­ï¼‰
            // åªæœ‰åœ¨å‰åå€¼éƒ½åœ¨æ­£å¸¸èŒƒå›´å†…ï¼Œä¸”å½“å‰å€¼å®Œå…¨ä¸ç¬¦åˆä»»ä½•æ¨¡å¼æ—¶æ‰åˆ¤å®šä¸ºå¼‚å¸¸
            for (let i = 3; i < n - 3; i++) {
                // è®¡ç®—æ›´å¤§çª—å£çš„ç»Ÿè®¡ï¼ˆæ’é™¤å½“å‰ç‚¹ï¼‰
                let localSum = 0;
                let localCount = 0;
                for (let j = i - 3; j <= i + 3; j++) {
                    if (j !== i) {
                        localSum += data[j];
                        localCount++;
                    }
                }
                const localMean = localSum / localCount;
                
                // è®¡ç®—å±€éƒ¨æ ‡å‡†å·®
                let localVariance = 0;
                for (let j = i - 3; j <= i + 3; j++) {
                    if (j !== i) {
                        localVariance += Math.pow(data[j] - localMean, 2);
                    }
                }
                const localStdDev = Math.sqrt(localVariance / localCount);
                
                // éå¸¸ä¸¥æ ¼çš„å¼‚å¸¸åˆ¤æ–­ï¼šåç¦»è¶…è¿‡5å€æ ‡å‡†å·®ï¼Œä¸”åç¦»å¹…åº¦è¶…è¿‡æ•°æ®èŒƒå›´çš„50%
                // å¹¶ä¸”å‰åå€¼éƒ½åœ¨æ­£å¸¸èŒƒå›´å†…ï¼ˆåœ¨å±€éƒ¨å‡å€¼çš„1.5å€æ ‡å‡†å·®å†…ï¼‰
                const deviation = Math.abs(data[i] - localMean);
                const dataRange = Math.max(...data) - Math.min(...data);
                
                if (deviation > Math.max(localStdDev * 5, dataRange * 0.5)) {
                    // æ£€æŸ¥å‰åå€¼æ˜¯å¦éƒ½åœ¨æ­£å¸¸èŒƒå›´å†…
                    const prevNormal = Math.abs(data[i - 1] - localMean) < localStdDev * 1.5;
                    const nextNormal = Math.abs(data[i + 1] - localMean) < localStdDev * 1.5;
                    const prev2Normal = Math.abs(data[i - 2] - localMean) < localStdDev * 1.5;
                    const next2Normal = Math.abs(data[i + 2] - localMean) < localStdDev * 1.5;
                    
                    // åªæœ‰å‰åå¤šä¸ªå€¼éƒ½åœ¨æ­£å¸¸èŒƒå›´å†…ï¼Œä¸”å½“å‰å€¼æç«¯å¼‚å¸¸æ—¶ï¼Œæ‰åˆ¤å®šä¸ºå¼‚å¸¸
                    if (prevNormal && nextNormal && prev2Normal && next2Normal) {
                        anomalies.push({ index: i, change: deviation });
                    }
                }
            }
            
            return anomalies;
        }
        
        // 2. è®¡ç®—ç»Ÿè®¡ç‰¹å¾
        function calculateStatistics(data) {
            const n = data.length;
            if (n === 0) {
                return { mean: 0, variance: 0, stdDev: 0, range: 0, max: 0, min: 0 };
            }
            
            let sum = 0;
            let sumSq = 0;
            let max = data[0];
            let min = data[0];
            
            for (let i = 0; i < n; i++) {
                sum += data[i];
                sumSq += data[i] * data[i];
                if (data[i] > max) max = data[i];
                if (data[i] < min) min = data[i];
            }
            
            const mean = sum / n;
            const variance = (sumSq / n) - (mean * mean);
            const stdDev = Math.sqrt(Math.max(0, variance));
            const range = max - min;
            
            return { mean, variance, stdDev, range, max, min };
        }
        
        // 3. æ£€æµ‹æœ€å¤§å€¼å’Œæœ€å°å€¼çš„ä½ç½®
        function findMaxMinPositions(data) {
            const maxPositions = [];
            const minPositions = [];
            const maxValues = [];
            const minValues = [];
            const n = data.length;
            
            // æ£€æµ‹å±€éƒ¨æœ€å¤§å€¼
            for (let i = 1; i < n - 1; i++) {
                if (data[i] > data[i - 1] && data[i] > data[i + 1]) {
                    maxPositions.push(i);
                    maxValues.push(data[i]);
                }
            }
            
            // æ£€æµ‹å±€éƒ¨æœ€å°å€¼
            for (let i = 1; i < n - 1; i++) {
                if (data[i] < data[i - 1] && data[i] < data[i + 1]) {
                    minPositions.push(i);
                    minValues.push(data[i]);
                }
            }
            
            return { maxPositions, minPositions, maxValues, minValues };
        }
        
        // 4. æ£€æµ‹æœ€å¤§å€¼æœ€å°å€¼çš„å‘¨æœŸæ€§ï¼ˆé€šè¿‡é—´éš”åˆ†æï¼‰
        function analyzePeriodicity(positions) {
            if (positions.length < 3) return { hasPeriodicity: false, period: 0, regularity: 0 };
            
            // è®¡ç®—é—´éš”
            const intervals = [];
            for (let i = 1; i < positions.length; i++) {
                intervals.push(positions[i] - positions[i - 1]);
            }
            
            // è®¡ç®—å¹³å‡é—´éš”å’Œå˜å¼‚ç³»æ•°
            let sum = 0;
            let sumSq = 0;
            for (let i = 0; i < intervals.length; i++) {
                sum += intervals[i];
                sumSq += intervals[i] * intervals[i];
            }
            
            const meanInterval = sum / intervals.length;
            const variance = (sumSq / intervals.length) - (meanInterval * meanInterval);
            const stdDev = Math.sqrt(Math.max(0, variance));
            const cv = meanInterval > 0 ? stdDev / meanInterval : 1.0; // å˜å¼‚ç³»æ•°
            
            // è§„å¾‹æ€§è¯„åˆ†ï¼šå˜å¼‚ç³»æ•°è¶Šå°ï¼Œè§„å¾‹æ€§è¶Šé«˜
            const regularity = Math.max(0, 1.0 - cv);
            
            // åˆ¤æ–­æ˜¯å¦æœ‰å‘¨æœŸæ€§ï¼šè§„å¾‹æ€§>0.6è®¤ä¸ºæœ‰å‘¨æœŸæ€§
            const hasPeriodicity = regularity > 0.6;
            
            return { hasPeriodicity, period: meanInterval, regularity };
        }
        
        // 5. æ£€æµ‹æœ€å¤§å€¼æœ€å°å€¼çš„ç›¸å¯¹å›ºå®šæ€§ï¼ˆå¤§å°ç›¸å¯¹å›ºå®šï¼‰
        function analyzeValueStability(values) {
            if (values.length < 2) return { isStable: false, stability: 0 };
            
            // è®¡ç®—ç»Ÿè®¡ç‰¹å¾
            let sum = 0;
            let sumSq = 0;
            for (let i = 0; i < values.length; i++) {
                sum += values[i];
                sumSq += values[i] * values[i];
            }
            
            const mean = sum / values.length;
            const variance = (sumSq / values.length) - (mean * mean);
            const stdDev = Math.sqrt(Math.max(0, variance));
            const cv = mean > 0 ? stdDev / mean : 1.0; // å˜å¼‚ç³»æ•°
            
            // ç¨³å®šæ€§è¯„åˆ†ï¼šå˜å¼‚ç³»æ•°è¶Šå°ï¼Œç¨³å®šæ€§è¶Šé«˜
            const stability = Math.max(0, 1.0 - cv * 2); // ä¹˜ä»¥2ä½¿é˜ˆå€¼æ›´ä¸¥æ ¼
            
            // åˆ¤æ–­æ˜¯å¦ç¨³å®šï¼šç¨³å®šæ€§>0.5è®¤ä¸ºç›¸å¯¹å›ºå®š
            const isStable = stability > 0.5;
            
            return { isStable, stability };
        }
        
        // 6. ä¸»æ£€æµ‹å‡½æ•°ï¼ˆæ–°æ€è·¯ï¼šç®€æ´ã€å‡†ç¡®ï¼Œä¼˜å…ˆåˆ¤æ–­é¢‘é—ªï¼‰
        function analyzeStrobeData() {
            if (strobeDataCollection.length < 20) {
                return 'æ£€æµ‹å¤±è´¥ï¼šæ•°æ®ç‚¹ä¸è¶³ (ä»…æ”¶é›†åˆ° ' + strobeDataCollection.length + ' ä¸ªæ•°æ®ç‚¹ï¼Œéœ€è¦è‡³å°‘20ä¸ª)';
            }
            
            // æå–åŸå§‹æ•°æ®ï¼ˆä¸åšä»»ä½•æ»¤æ³¢ï¼‰
            const rawData = strobeDataCollection.map(d => d.value);
            const n = rawData.length;
            
            // æ­¥éª¤1ï¼šæ£€æµ‹æç«¯å¼‚å¸¸çªå˜ï¼ˆéå¸¸å®½æ¾ï¼Œåªæ£€æµ‹æ˜æ˜¾å¼‚å¸¸ï¼‰
            const anomalies = detectAnomalies(rawData);
            // åªæœ‰åœ¨æ£€æµ‹åˆ°å¤šä¸ªæç«¯å¼‚å¸¸æ—¶æ‰åˆ¤å®šä¸ºæ±¡æŸ“ï¼ˆå…è®¸å°‘é‡å¼‚å¸¸å€¼ï¼‰
            if (anomalies.length > n * 0.1) { // è¶…è¿‡10%çš„æ•°æ®ç‚¹æ˜¯å¼‚å¸¸æ‰åˆ¤å®šä¸ºæ±¡æŸ“
                return `âš ï¸ æ•°æ®æºæ±¡æŸ“ï¼šæ£€æµ‹åˆ°å¤§é‡å¼‚å¸¸çªå˜ï¼ˆå…±${anomalies.length}å¤„ï¼Œå ${(anomalies.length / n * 100).toFixed(1)}%ï¼‰ï¼Œæ— æ³•åˆ¤æ–­æ˜¯å¦é¢‘é—ªã€‚è¯·ç¡®ä¿æµ‹è¯•ç¯å¢ƒç¨³å®šï¼Œé¿å…å…‰æºç§»åŠ¨æˆ–é®æŒ¡ã€‚ (æ•°æ®ç‚¹: ${n})`;
            }
            
            // æ­¥éª¤2ï¼šè®¡ç®—ç»Ÿè®¡ç‰¹å¾
            const stats = calculateStatistics(rawData);
            
            // æ­¥éª¤3ï¼šåˆ¤æ–­æ— é¢‘é—ª - å‡ ä¹æ— å˜åŠ¨ï¼Œä»…æœ‰æå°éšæœºæ€§æ³¢åŠ¨
            const stabilityThreshold = Math.max(stats.mean * 0.02, 10); // 2%æˆ–è‡³å°‘10
            if (stats.stdDev < stabilityThreshold && stats.range < stabilityThreshold * 5) {
                return `æœªå‘ç°æ˜æ˜¾é¢‘é—ªï¼šæ•°å€¼å‡ ä¹æ— å˜åŒ–ï¼Œä»…æœ‰æå°éšæœºæ€§æ³¢åŠ¨ (æ ‡å‡†å·®: ${stats.stdDev.toFixed(2)}, èŒƒå›´: ${stats.range.toFixed(2)}, æ•°æ®ç‚¹: ${n})`;
            }
            
            // æ­¥éª¤4ï¼šæ£€æµ‹æœ€å¤§å€¼å’Œæœ€å°å€¼çš„ä½ç½®
            const { maxPositions, minPositions, maxValues, minValues } = findMaxMinPositions(rawData);
            
            // éœ€è¦è‡³å°‘2ä¸ªæœ€å¤§å€¼å’Œ2ä¸ªæœ€å°å€¼æ‰èƒ½åˆ¤æ–­ï¼ˆé™ä½è¦æ±‚ä»¥é€‚åº”éšæœºæ€§ï¼‰
            if (maxPositions.length < 2 || minPositions.length < 2) {
                // å¦‚æœæœ€å¤§å€¼æˆ–æœ€å°å€¼å¤ªå°‘ï¼Œä½†æ•°æ®æœ‰æ˜æ˜¾æ³¢åŠ¨ï¼Œå¯èƒ½æ˜¯æ•°æ®æºæ±¡æŸ“
                if (stats.range > stats.mean * 0.3) {
                    return `âš ï¸ æ•°æ®æºæ±¡æŸ“ï¼šæœ€å¤§å€¼æˆ–æœ€å°å€¼æ•°é‡ä¸è¶³ï¼Œä¸”æ•°æ®æ³¢åŠ¨è¾ƒå¤§ï¼Œæ— æ³•åˆ¤æ–­å‘¨æœŸæ€§ã€‚è¯·ç¡®ä¿æµ‹è¯•ç¯å¢ƒç¨³å®šã€‚ (æœ€å¤§å€¼: ${maxPositions.length}, æœ€å°å€¼: ${minPositions.length}, èŒƒå›´: ${stats.range.toFixed(2)}, æ•°æ®ç‚¹: ${n})`;
                } else {
                    return `æœªå‘ç°æ˜æ˜¾é¢‘é—ªï¼šæ•°æ®æ³¢åŠ¨è¾ƒå°ï¼Œæœ€å¤§å€¼æˆ–æœ€å°å€¼æ•°é‡ä¸è¶³ (æœ€å¤§å€¼: ${maxPositions.length}, æœ€å°å€¼: ${minPositions.length}, èŒƒå›´: ${stats.range.toFixed(2)}, æ•°æ®ç‚¹: ${n})`;
                }
            }
            
            // æ­¥éª¤5ï¼šæ£€æµ‹æœ€å¤§å€¼æœ€å°å€¼çš„å‘¨æœŸæ€§
            const maxPeriodicity = analyzePeriodicity(maxPositions);
            const minPeriodicity = analyzePeriodicity(minPositions);
            
            // æ­¥éª¤6ï¼šæ£€æµ‹æœ€å¤§å€¼æœ€å°å€¼çš„ç›¸å¯¹å›ºå®šæ€§ï¼ˆå¤§å°ç›¸å¯¹å›ºå®šï¼‰
            const maxStability = analyzeValueStability(maxValues);
            const minStability = analyzeValueStability(minValues);
            
            // æ­¥éª¤7ï¼šç»¼åˆåˆ¤æ–­é¢‘é—ªï¼ˆè¿›ä¸€æ­¥æ”¾å®½æ¡ä»¶ä»¥é€‚åº”éšæœºæ€§ï¼‰
            // é¢‘é—ªçš„æ ¸å¿ƒç‰¹å¾ï¼šæœ€å¤§å€¼å’Œæœ€å°å€¼çš„æ•°å€¼ç›¸å¯¹å›ºå®šï¼ˆç¨³å®šæ€§ï¼‰
            // å‘¨æœŸæ€§å¯èƒ½å› ä¸ºéšæœºæ€§è€Œé™ä½ï¼Œä½†å¦‚æœç¨³å®šæ€§å¥½ï¼Œä»ç„¶å¯ä»¥åˆ¤å®šä¸ºé¢‘é—ª
            
            // é™ä½å‘¨æœŸæ€§é˜ˆå€¼ï¼Œé€‚åº”éšæœºæ€§
            const hasMaxPeriodicity = maxPeriodicity.regularity > 0.3;  // ä»0.5é™åˆ°0.3
            const hasMinPeriodicity = minPeriodicity.regularity > 0.3;  // ä»0.5é™åˆ°0.3
            const hasMaxStability = maxStability.stability > 0.4;
            const hasMinStability = minStability.stability > 0.4;
            
            // è¿›ä¸€æ­¥æ”¾å®½ï¼šå¦‚æœç¨³å®šæ€§å¾ˆå¥½ï¼Œå³ä½¿å‘¨æœŸæ€§ç¨ä½ä¹Ÿå¯ä»¥
            const hasGoodMaxStability = maxStability.stability > 0.6;
            const hasGoodMinStability = minStability.stability > 0.5;
            const hasWeakMaxPeriodicity = maxPeriodicity.regularity > 0.2;  // å¾ˆä½çš„å‘¨æœŸæ€§è¦æ±‚
            const hasWeakMinPeriodicity = minPeriodicity.regularity > 0.2;  // å¾ˆä½çš„å‘¨æœŸæ€§è¦æ±‚
            
            // åˆ¤æ–­1ï¼šæ ‡å‡†é¢‘é—ªï¼ˆå‘¨æœŸæ€§å’Œç¨³å®šæ€§éƒ½æ»¡è¶³ï¼‰
            if (hasMaxPeriodicity && hasMinPeriodicity && hasMaxStability && hasMinStability) {
                const avgPeriod = (maxPeriodicity.period + minPeriodicity.period) / 2;
                const avgRegularity = (maxPeriodicity.regularity + minPeriodicity.regularity) / 2;
                const avgStability = (maxStability.stability + minStability.stability) / 2;
                const confidence = (avgRegularity + avgStability) / 2;
                
                return `å­˜åœ¨é¢‘é—ªï¼šæ£€æµ‹åˆ°å‘¨æœŸæ€§æ³¢åŠ¨ï¼Œæœ€å¤§å€¼å’Œæœ€å°å€¼å‡å…·æœ‰å‘¨æœŸæ€§å’Œç›¸å¯¹å›ºå®šæ€§ (å¹³å‡å‘¨æœŸ: ${avgPeriod.toFixed(1)}, è§„å¾‹æ€§: ${(avgRegularity * 100).toFixed(1)}%, ç¨³å®šæ€§: ${(avgStability * 100).toFixed(1)}%, ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(1)}%, æœ€å¤§å€¼æ•°: ${maxPositions.length}, æœ€å°å€¼æ•°: ${minPositions.length}, æ•°æ®ç‚¹: ${n})`;
            }
            
            // åˆ¤æ–­2ï¼šç¨³å®šæ€§ä¼˜å…ˆï¼ˆç¨³å®šæ€§å¥½ï¼Œå‘¨æœŸæ€§ç¨ä½ä¹Ÿå¯ä»¥åˆ¤å®šä¸ºé¢‘é—ªï¼‰
            if (hasGoodMaxStability && hasGoodMinStability && hasWeakMaxPeriodicity && hasWeakMinPeriodicity) {
                const avgPeriod = (maxPeriodicity.period + minPeriodicity.period) / 2;
                const avgRegularity = (maxPeriodicity.regularity + minPeriodicity.regularity) / 2;
                const avgStability = (maxStability.stability + minStability.stability) / 2;
                // ç¨³å®šæ€§æƒé‡æ›´é«˜
                const confidence = (avgRegularity * 0.3 + avgStability * 0.7);
                
                return `å­˜åœ¨é¢‘é—ªï¼šæ£€æµ‹åˆ°å‘¨æœŸæ€§æ³¢åŠ¨ï¼ˆå¸¦æœ‰éšæœºæ€§ï¼‰ï¼Œæœ€å¤§å€¼å’Œæœ€å°å€¼æ•°å€¼ç›¸å¯¹å›ºå®š (å¹³å‡å‘¨æœŸ: ${avgPeriod.toFixed(1)}, è§„å¾‹æ€§: ${(avgRegularity * 100).toFixed(1)}%, ç¨³å®šæ€§: ${(avgStability * 100).toFixed(1)}%, ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(1)}%, æœ€å¤§å€¼æ•°: ${maxPositions.length}, æœ€å°å€¼æ•°: ${minPositions.length}, æ•°æ®ç‚¹: ${n})`;
            }
            
            // åˆ¤æ–­3ï¼šè‡³å°‘ç¨³å®šæ€§æ»¡è¶³ï¼Œä¸”æœ‰ä¸€å®šå‘¨æœŸæ€§
            if (hasMaxStability && hasMinStability && (hasWeakMaxPeriodicity || hasWeakMinPeriodicity)) {
                const avgPeriod = (maxPeriodicity.period + minPeriodicity.period) / 2;
                const avgRegularity = (maxPeriodicity.regularity + minPeriodicity.regularity) / 2;
                const avgStability = (maxStability.stability + minStability.stability) / 2;
                const confidence = (avgRegularity * 0.3 + avgStability * 0.7);
                
                return `å­˜åœ¨é¢‘é—ªï¼šæ£€æµ‹åˆ°å‘¨æœŸæ€§æ³¢åŠ¨ï¼ˆå¸¦æœ‰éšæœºæ€§ï¼‰ï¼Œæœ€å¤§å€¼å’Œæœ€å°å€¼æ•°å€¼ç›¸å¯¹å›ºå®š (å¹³å‡å‘¨æœŸ: ${avgPeriod.toFixed(1)}, è§„å¾‹æ€§: ${(avgRegularity * 100).toFixed(1)}%, ç¨³å®šæ€§: ${(avgStability * 100).toFixed(1)}%, ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(1)}%, æœ€å¤§å€¼æ•°: ${maxPositions.length}, æœ€å°å€¼æ•°: ${minPositions.length}, æ•°æ®ç‚¹: ${n})`;
            }
            
            // æ­¥éª¤8ï¼šæ— æ³•ç¡®å®š - åˆ¤å®šä¸ºæ•°æ®æºæ±¡æŸ“
            return `âš ï¸ æ•°æ®æºæ±¡æŸ“ï¼šæ— æ³•ç¡®å®šæ˜¯å¦å­˜åœ¨é¢‘é—ªã€‚æœ€å¤§å€¼å‘¨æœŸæ€§: ${hasMaxPeriodicity ? 'æ˜¯' : 'å¦'}(${(maxPeriodicity.regularity * 100).toFixed(1)}%), æœ€å°å€¼å‘¨æœŸæ€§: ${hasMinPeriodicity ? 'æ˜¯' : 'å¦'}(${(minPeriodicity.regularity * 100).toFixed(1)}%), æœ€å¤§å€¼ç¨³å®šæ€§: ${hasMaxStability ? 'æ˜¯' : 'å¦'}(${(maxStability.stability * 100).toFixed(1)}%), æœ€å°å€¼ç¨³å®šæ€§: ${hasMinStability ? 'æ˜¯' : 'å¦'}(${(minStability.stability * 100).toFixed(1)}%)ã€‚è¯·ç¡®ä¿æµ‹è¯•ç¯å¢ƒç¨³å®šã€‚ (æ•°æ®ç‚¹: ${n})`;
        }

        // ä¸‹è½½æ•°æ® - ä»æµè§ˆå™¨ç«¯å­˜å‚¨ä¸‹è½½
        function downloadCSV() {
            if (clientDataStore.length === 0) {
                alert('æ²¡æœ‰å¯ä¸‹è½½çš„æ•°æ®ï¼Œè¯·ç­‰å¾…æ•°æ®åŒæ­¥');
                return;
            }
            
            try {
                let csvData = 'æ—¶é—´æˆ³,æœ¬åœ°æ—¶é—´,ADCå€¼,ç”µå‹(V),ESP32è¿è¡Œæ—¶é—´(ms)\n';
                
                for (let i = 0; i < clientDataStore.length; i++) {
                    const point = clientDataStore[i];
                    const date = new Date(point.timestamp);
                    csvData += point.timestamp + ',';
                    csvData += date.toLocaleString() + ',';
                    csvData += point.value + ',';
                    csvData += point.voltage.toFixed(3) + ',';
                    csvData += (point.uptime || 0) + '\n';
                }
                
                const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `light_sensor_data_${new Date().getTime()}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                alert(`æ•°æ®ä¸‹è½½æˆåŠŸï¼å…± ${clientDataStore.length} ä¸ªæ•°æ®ç‚¹`);
            } catch (error) {
                console.error('ä¸‹è½½å¤±è´¥:', error);
                alert('æ•°æ®ä¸‹è½½å¤±è´¥: ' + error.message);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = function() {
            initChart();
            // è¿æ¥WebSocket
            connectWebSocket();
        };
        
        // é¡µé¢å…³é—­æ—¶æ¸…ç†
        window.onbeforeunload = function() {
            if (ws) {
                ws.close();
            }
            if (wsReconnectInterval) {
                clearInterval(wsReconnectInterval);
            }
        };
    </script>
</body>
</html>
